## 개요
이 리포지토리는 ANTLR을 사용하여 소스 코드로부터 파싱 트리를 생성하고, 해당 트리를 기반으로 문법에 맞는 인터프리터를 구현하는 과제입니다. 이 과제는 두 가지 방법으로 수행됩니다:  
1. Java를 사용한 구현:  
ANTLR을 이용하여 소스 코드의 구문을 파싱하고, 파싱 트리(parse tree)를 생성합니다.  
생성된 파싱 트리를 기반으로 AST(Abstract Syntax Tree)를 구성하고, 이를 통해 소스 코드를 해석 및 실행하는 인터프리터를 구현합니다.  
2. OCaml을 사용한 구현:  
OCaml에서 ANTLR로 생성된 파싱 트리를 바탕으로 문법을 분석하고, 인터프리터를 개발합니다.  
Java와 유사하게, 파싱 트리에서 AST를 구성하여 소스 코드의 의미를 해석하고 실행합니다.

## 내용
### PA1-ANTLR : ANTLR를 이용하여 사칙연산이 가능한 인터프리터 구현하기
ANTLR를 이용하여 생성한 parse tree를 AST(Abstract Syntax Tree)를 만들어 값을 계산하는 계산기를 만드는 것입니다. 이 과정에서 ANTLR Visitor 클래스를 이용하여 AST 노드를 구성하는 데에 필요한 노드만을 간추려 재구성합니다.
- sample로 제공된 program.java의 코드 분석을 통해 전체 코드 구성에 관해 디자인하였습니다. ANTLR를 통해 생성된 Lexer, Parser 클래스를 이용해 parse tree를 만들어 ctx로 저장 후, 이 ctx를 이용해 AST를 생성합니다.
- 생성된 AST는 ;를 통해 구분되는 tree의 루트 노드를 저장하고 있는 리스트와 변수를 저장하는 해시맵을 포함하는 클래스 ExprTree 인스턴스입니다.
- tree 리스트를 이용해 각 루트 노드 별 Call과 Evaluate 함수를 진행하여 트리별 독립적인 함수 실행이 되도록 합니다.
  
### PA1-OCAML : 제시된 1~7번 문제를 해결하는 알고리즘 작성하기
PA2를 수행하기 위해 간단한 예제를 통해 OCAML 문법을 익히기 위한 과제입니다.

### PA2: OCAML로 F1VAE를 만족시키는 인터프리터 구현하기
PA2는 ocaml로 F1VAE를 만족시키는 인터프리터를 구현하는 작업입니다.  
- 함수와 변수 설정을 위해 fstore를 이용하였으며, 각각의 함수와 변수의 실제 값은 fstore에 저장되어 값을 반환해야 할 경우, 값을 꺼내어 사용합니다.
- interpreter.ml 파일만을 변경하였으며, 관련 내용을 구현하기 위한 모든 코드를 확인할 수 있습니다.
- to run: `dune runtest`
### PA3: 기존 PA1-ANTLR 인터프리터를 F1VAE를 만족하는 인터프리터로 확장하기
PA3는 이전 과제(PA1)에서 생성한 AST를 확장하여 F1VAE 문법을 만족하도록 하는 작업입니다. 주요 목표는 함수 정의, 함수 호출, 변수 선언 및 범위 설정, 부정 연산의 4가지 기능을 구현하는 것입니다.
- 함수와 변수의 저장 공간 분리: 함수와 변수를 각각 다른 저장 공간에 관리하여 효율적인 메모리 사용을 목표로 설계했습니다.
- 변수 값 확정: 변수 선언 시 즉시 값을 저장하지 않고, 표현식이 평가된 후에 최종 값이 확정되도록 구현했습니다.
- Free Identifier 탐지: Visitor 패턴을 활용하여 선언되지 않은 변수를 탐지할 수 있도록 변수의 심볼(symbol)을 저장하고 관리했습니다.
- 함수 호출 검증: 선언되지 않은 함수 호출을 탐지하기 위해 함수 노드를 배열 리스트에 저장하고, 호출 시 이를 대조하여 검증합니다.
